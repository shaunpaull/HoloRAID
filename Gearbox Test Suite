#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                                      â•‘
â•‘   ğŸŒªï¸ğŸ’œ HYPERMORPHIC HOLOGRAPHIC GEARBOX - COMPREHENSIVE TEST SUITE ğŸ’œğŸŒªï¸                             â•‘
â•‘                                                                                                      â•‘
â•‘   Deep dive testing of:                                                                              â•‘
â•‘   â€¢ SafeGear bijective transformations                                                               â•‘
â•‘   â€¢ Winding/unwinding dynamics                                                                       â•‘
â•‘   â€¢ Gear ratios and multiplicative orbits                                                            â•‘
â•‘   â€¢ Multi-gear compositions                                                                          â•‘
â•‘   â€¢ Holographic distribution properties                                                              â•‘
â•‘   â€¢ Edge cases and boundary conditions                                                               â•‘
â•‘   â€¢ Information-theoretic guarantees                                                                 â•‘
â•‘   â€¢ Gauge-theoretic structure                                                                        â•‘
â•‘                                                                                                      â•‘
â•‘   Author: Shaun Paul                                                                                 â•‘
â•‘   Framework: HyperMorphic Research                                                                   â•‘
â•‘                                                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import math
import time
import random
import hashlib
import secrets
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Tuple, Set
from functools import reduce
from itertools import combinations, permutations
from collections import defaultdict, Counter

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CORE MATHEMATICS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def gcd(a: int, b: int) -> int:
    """Euclidean algorithm."""
    while b:
        a, b = b, a % b
    return a

def lcm(a: int, b: int) -> int:
    """Least common multiple."""
    return abs(a * b) // gcd(a, b)

def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
    """Extended Euclidean algorithm. Returns (gcd, x, y) where ax + by = gcd."""
    if b == 0:
        return a, 1, 0
    g, x, y = extended_gcd(b, a % b)
    return g, y, x - (a // b) * y

def mod_inverse(a: int, m: int) -> int:
    """Modular multiplicative inverse."""
    g, x, _ = extended_gcd(a % m, m)
    if g != 1:
        raise ValueError(f"No inverse: gcd({a}, {m}) = {g}")
    return x % m

def is_prime(n: int) -> bool:
    """Primality test."""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True

def next_prime(n: int) -> int:
    """Find next prime >= n."""
    if n < 2:
        return 2
    if n == 2:
        return 2
    if n % 2 == 0:
        n += 1
    while not is_prime(n):
        n += 2
    return n

def euler_totient(n: int) -> int:
    """Euler's totient function Ï†(n)."""
    result = n
    p = 2
    while p * p <= n:
        if n % p == 0:
            while n % p == 0:
                n //= p
            result -= result // p
        p += 1
    if n > 1:
        result -= result // n
    return result

def multiplicative_order(a: int, n: int) -> int:
    """Find the multiplicative order of a mod n (smallest k where a^k â‰¡ 1)."""
    if gcd(a, n) != 1:
        return -1  # No order exists
    
    order = 1
    current = a % n
    while current != 1:
        current = (current * a) % n
        order += 1
        if order > n:  # Safety check
            return -1
    return order

def is_primitive_root(g: int, p: int) -> bool:
    """Check if g is a primitive root mod p."""
    if not is_prime(p):
        return False
    return multiplicative_order(g, p) == p - 1

def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> int:
    """CRT: Find x such that x â‰¡ r_i (mod m_i) for all i."""
    M = reduce(lambda a, b: a * b, moduli)
    x = 0
    for r, m in zip(remainders, moduli):
        Mi = M // m
        yi = mod_inverse(Mi, m)
        x += r * Mi * yi
    return x % M


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# THE SAFEGEAR: CORE TRANSFORMATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class SafeGear:
    """
    THE SAFEGEAR: A Bijective Winding Transformation
    
    For modulus m and base b (coprime to m):
        wind(x) = (b * x) mod m
        unwind(y) = (b^{-1} * y) mod m
    
    Properties:
    - Bijective (one-to-one and onto)
    - Invertible (unwind reverses wind)
    - Forms a cyclic group under composition
    - Orbit length divides Ï†(m)
    """
    
    modulus: int
    base: int
    _inverse: int = field(init=False, repr=False)
    _order: int = field(init=False, repr=False)
    
    def __post_init__(self):
        if gcd(self.base, self.modulus) != 1:
            raise ValueError(f"Base {self.base} and modulus {self.modulus} must be coprime")
        self._inverse = mod_inverse(self.base, self.modulus)
        self._order = multiplicative_order(self.base, self.modulus)
    
    @property
    def inverse_base(self) -> int:
        return self._inverse
    
    @property
    def order(self) -> int:
        """Multiplicative order: smallest k where base^k â‰¡ 1 (mod modulus)."""
        return self._order
    
    def wind(self, x: int) -> int:
        """Forward transformation: x â†’ (b * x) mod m."""
        return (self.base * x) % self.modulus
    
    def unwind(self, y: int) -> int:
        """Inverse transformation: y â†’ (b^{-1} * y) mod m."""
        return (self._inverse * y) % self.modulus
    
    def wind_n(self, x: int, n: int) -> int:
        """Wind n times: x â†’ (b^n * x) mod m."""
        # Use fast exponentiation
        bn = pow(self.base, n % self._order, self.modulus)
        return (bn * x) % self.modulus
    
    def unwind_n(self, y: int, n: int) -> int:
        """Unwind n times: y â†’ (b^{-n} * y) mod m."""
        bn_inv = pow(self._inverse, n % self._order, self.modulus)
        return (bn_inv * y) % self.modulus
    
    def orbit(self, x: int) -> List[int]:
        """Return the complete orbit of x under winding."""
        orbit = [x]
        current = self.wind(x)
        while current != x:
            orbit.append(current)
            current = self.wind(current)
        return orbit
    
    def orbit_length(self, x: int) -> int:
        """Length of the orbit containing x."""
        if x == 0:
            return 1  # 0 maps to 0
        return self._order


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# THE HOLOGRAPHIC GEARBOX
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class HolographicGearbox:
    """
    THE HOLOGRAPHIC GEARBOX
    
    A collection of n SafeGears with coprime moduli that together
    implement holographic information distribution.
    
    Key Properties:
    - Each gear operates independently
    - Together they form a product space
    - CRT provides the holographic projection/reconstruction
    - Information is distributed non-locally across all gears
    """
    
    n_gears: int
    k_threshold: int
    prime_start: int = 65537
    base: int = 2
    
    gears: List[SafeGear] = field(init=False, repr=False)
    moduli: List[int] = field(init=False, repr=False)
    capacity: int = field(init=False, repr=False)
    
    def __post_init__(self):
        # Generate prime moduli
        self.moduli = []
        p = self.prime_start
        for _ in range(self.n_gears):
            p = next_prime(p)
            self.moduli.append(p)
            p += 2
        
        # Create gears
        self.gears = [SafeGear(m, self.base) for m in self.moduli]
        
        # Compute capacity (product of k smallest moduli)
        sorted_moduli = sorted(self.moduli)
        self.capacity = reduce(lambda a, b: a * b, sorted_moduli[:self.k_threshold])
    
    def project(self, value: int) -> List[int]:
        """
        Holographic projection: Bulk â†’ Boundary.
        Maps a value to its residues across all gears.
        """
        return [value % m for m in self.moduli]
    
    def wind_all(self, residues: List[int]) -> List[int]:
        """Apply winding to all residues."""
        return [g.wind(r) for g, r in zip(self.gears, residues)]
    
    def unwind_all(self, wound: List[int]) -> List[int]:
        """Remove winding from all residues."""
        return [g.unwind(w) for g, w in zip(self.gears, wound)]
    
    def reconstruct(self, residues: List[int], 
                    indices: Optional[List[int]] = None) -> int:
        """
        Holographic reconstruction: Boundary â†’ Bulk.
        Reconstruct value from k residues using CRT.
        """
        if indices is None:
            indices = list(range(self.k_threshold))
        
        if len(indices) < self.k_threshold:
            raise ValueError(f"Need {self.k_threshold} residues, got {len(indices)}")
        
        use_residues = [residues[i] for i in indices[:self.k_threshold]]
        use_moduli = [self.moduli[i] for i in indices[:self.k_threshold]]
        
        return chinese_remainder_theorem(use_residues, use_moduli)
    
    def encode(self, value: int) -> List[int]:
        """Full encoding: project then wind."""
        residues = self.project(value)
        return self.wind_all(residues)
    
    def decode(self, wound: List[int], 
               available: Optional[List[int]] = None) -> int:
        """Full decoding: unwind then reconstruct."""
        residues = self.unwind_all(wound)
        return self.reconstruct(residues, available)
    
    def gear_info(self, index: int) -> Dict[str, Any]:
        """Get detailed information about a specific gear."""
        gear = self.gears[index]
        return {
            'index': index,
            'modulus': gear.modulus,
            'base': gear.base,
            'inverse_base': gear.inverse_base,
            'order': gear.order,
            'totient': euler_totient(gear.modulus),
            'order_ratio': gear.order / euler_totient(gear.modulus),
            'is_primitive_root': is_primitive_root(gear.base, gear.modulus)
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMPREHENSIVE TEST SUITE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                                      â•‘
â•‘   ğŸŒªï¸ğŸ’œ HYPERMORPHIC HOLOGRAPHIC GEARBOX TEST SUITE ğŸ’œğŸŒªï¸                                             â•‘
â•‘                                                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")

class GearboxTestSuite:
    """Comprehensive test suite for the Holographic Gearbox."""
    
    def __init__(self):
        self.results = {
            'passed': 0,
            'failed': 0,
            'tests': []
        }
    
    def test(self, name: str, func, category: str = "General"):
        """Run a test and record results."""
        try:
            start = time.time()
            result, details = func()
            elapsed = time.time() - start
            
            if result:
                self.results['passed'] += 1
                status = "âœ… PASS"
            else:
                self.results['failed'] += 1
                status = "âŒ FAIL"
            
            print(f"  {status}: {name} ({elapsed:.4f}s)")
            if details:
                for line in details.split('\n'):
                    if line.strip():
                        print(f"         {line}")
            
            self.results['tests'].append({
                'name': name,
                'category': category,
                'passed': result,
                'time': elapsed,
                'details': details
            })
            
            return result
        except Exception as e:
            self.results['failed'] += 1
            print(f"  âŒ FAIL: {name} - Exception: {e}")
            self.results['tests'].append({
                'name': name,
                'category': category,
                'passed': False,
                'error': str(e)
            })
            return False
    
    def run_all(self):
        """Run all tests."""
        self.test_safegear_fundamentals()
        self.test_winding_dynamics()
        self.test_multiplicative_structure()
        self.test_gearbox_holography()
        self.test_information_theory()
        self.test_gauge_structure()
        self.test_edge_cases()
        self.test_stress()
        self.test_mathematical_identities()
        self.print_summary()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 1: SAFEGEAR FUNDAMENTALS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_safegear_fundamentals(self):
        """Test fundamental SafeGear properties."""
        print("\n" + "â•" * 70)
        print("ğŸ”§ SAFEGEAR FUNDAMENTALS")
        print("â•" * 70)
        
        def test_bijection():
            """Verify SafeGear is a bijection."""
            gear = SafeGear(modulus=65537, base=2)
            
            # Test that wind is bijective
            outputs = set()
            for x in range(gear.modulus):
                y = gear.wind(x)
                if y in outputs:
                    return False, "Duplicate output found - not injective"
                outputs.add(y)
            
            if len(outputs) != gear.modulus:
                return False, "Missing outputs - not surjective"
            
            return True, f"All {gear.modulus} values map uniquely"
        
        def test_inverse():
            """Verify unwind is the inverse of wind."""
            gear = SafeGear(modulus=65537, base=2)
            
            # Test random values
            test_values = [0, 1, 42, 1000, 12345, 65536]
            for x in test_values:
                y = gear.wind(x)
                z = gear.unwind(y)
                if z != x:
                    return False, f"Inverse failed: wind({x})={y}, unwind({y})={z}"
            
            # Test all values
            for x in range(min(1000, gear.modulus)):
                if gear.unwind(gear.wind(x)) != x:
                    return False, f"Inverse failed at x={x}"
            
            return True, "windâ»Â¹(wind(x)) = x for all tested values"
        
        def test_coprimality_check():
            """Verify coprimality is enforced."""
            try:
                # This should fail - 6 and 4 share factor 2
                gear = SafeGear(modulus=6, base=4)
                return False, "Should have rejected non-coprime base"
            except ValueError:
                pass
            
            # This should succeed
            gear = SafeGear(modulus=7, base=3)
            return True, "Non-coprime bases correctly rejected"
        
        def test_identity_at_zero():
            """Verify 0 always maps to 0."""
            for m in [7, 11, 101, 65537]:
                for b in [2, 3, 5]:
                    if gcd(b, m) == 1:
                        gear = SafeGear(m, b)
                        if gear.wind(0) != 0 or gear.unwind(0) != 0:
                            return False, f"Zero not fixed for m={m}, b={b}"
            return True, "0 â†’ 0 for all gears"
        
        def test_wind_n_consistency():
            """Verify wind_n is consistent with repeated wind."""
            gear = SafeGear(modulus=101, base=3)
            
            for x in [1, 42, 99]:
                for n in [1, 2, 5, 10, 100]:
                    # Compute via repeated application
                    expected = x
                    for _ in range(n):
                        expected = gear.wind(expected)
                    
                    # Compute via wind_n
                    actual = gear.wind_n(x, n)
                    
                    if actual != expected:
                        return False, f"wind_n({x}, {n}) mismatch"
            
            return True, "wind_n matches repeated wind application"
        
        self.test("Bijection Property", test_bijection, "Fundamentals")
        self.test("Inverse Property", test_inverse, "Fundamentals")
        self.test("Coprimality Enforcement", test_coprimality_check, "Fundamentals")
        self.test("Zero Fixed Point", test_identity_at_zero, "Fundamentals")
        self.test("wind_n Consistency", test_wind_n_consistency, "Fundamentals")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 2: WINDING DYNAMICS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_winding_dynamics(self):
        """Test winding dynamics and orbits."""
        print("\n" + "â•" * 70)
        print("ğŸŒ€ WINDING DYNAMICS")
        print("â•" * 70)
        
        def test_orbit_closure():
            """Verify orbits are closed under winding."""
            gear = SafeGear(modulus=101, base=3)
            
            for start in [1, 5, 17, 42]:
                orbit = gear.orbit(start)
                
                # Every element in orbit should wind to another element in orbit
                orbit_set = set(orbit)
                for x in orbit:
                    if gear.wind(x) not in orbit_set:
                        return False, f"Orbit not closed at {x}"
            
            return True, "All orbits are closed"
        
        def test_orbit_length_divides_order():
            """Verify orbit lengths divide the multiplicative order."""
            gear = SafeGear(modulus=101, base=3)
            order = gear.order
            
            for x in range(1, 101):
                orbit_len = len(gear.orbit(x))
                if order % orbit_len != 0:
                    return False, f"Orbit length {orbit_len} doesn't divide order {order}"
            
            return True, f"All orbit lengths divide order={order}"
        
        def test_return_to_start():
            """Verify winding eventually returns to start."""
            gear = SafeGear(modulus=65537, base=2)
            
            test_values = [1, 42, 1000, 33333]
            for x in test_values:
                current = x
                steps = 0
                while True:
                    current = gear.wind(current)
                    steps += 1
                    if current == x:
                        break
                    if steps > gear.modulus:
                        return False, f"Never returned for x={x}"
                
                if steps != gear.order:
                    return False, f"Wrong orbit length for x={x}: {steps} vs {gear.order}"
            
            return True, f"All non-zero values return after {gear.order} steps"
        
        def test_orbit_partition():
            """Verify orbits partition the non-zero elements."""
            gear = SafeGear(modulus=101, base=3)
            
            covered = set([0])  # 0 is its own orbit
            orbit_count = 1
            
            for x in range(1, gear.modulus):
                if x not in covered:
                    orbit = gear.orbit(x)
                    for elem in orbit:
                        if elem in covered:
                            return False, f"Orbits overlap at {elem}"
                        covered.add(elem)
                    orbit_count += 1
            
            if len(covered) != gear.modulus:
                return False, f"Orbits don't cover all: {len(covered)} vs {gear.modulus}"
            
            return True, f"{orbit_count} orbits partition â„¤_{gear.modulus}"
        
        def test_winding_is_multiplication():
            """Verify winding is multiplication in the group."""
            gear = SafeGear(modulus=101, base=3)
            
            # wind(x) should equal (base * x) mod modulus
            for x in range(gear.modulus):
                expected = (gear.base * x) % gear.modulus
                actual = gear.wind(x)
                if actual != expected:
                    return False, f"wind({x}) = {actual} â‰  {expected}"
            
            return True, "wind(x) = (base Ã— x) mod m"
        
        self.test("Orbit Closure", test_orbit_closure, "Dynamics")
        self.test("Orbit Length Divides Order", test_orbit_length_divides_order, "Dynamics")
        self.test("Return to Start", test_return_to_start, "Dynamics")
        self.test("Orbits Partition Space", test_orbit_partition, "Dynamics")
        self.test("Winding is Multiplication", test_winding_is_multiplication, "Dynamics")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 3: MULTIPLICATIVE STRUCTURE
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_multiplicative_structure(self):
        """Test multiplicative group structure."""
        print("\n" + "â•" * 70)
        print("âœ–ï¸ MULTIPLICATIVE STRUCTURE")
        print("â•" * 70)
        
        def test_order_divides_totient():
            """Verify multiplicative order divides Ï†(m)."""
            test_cases = [
                (101, 2), (101, 3), (101, 5),
                (65537, 2), (65537, 3),
                (257, 2), (257, 3)
            ]
            
            for m, b in test_cases:
                gear = SafeGear(m, b)
                phi = euler_totient(m)
                if phi % gear.order != 0:
                    return False, f"Order {gear.order} doesn't divide Ï†({m})={phi}"
            
            return True, "ord(b) | Ï†(m) for all cases"
        
        def test_primitive_root_detection():
            """Test primitive root detection."""
            # 2 is a primitive root mod 101
            gear = SafeGear(101, 2)
            is_prim = is_primitive_root(2, 101)
            expected_order = 100  # Ï†(101) = 100
            
            if gear.order != expected_order:
                return False, f"Order should be {expected_order}, got {gear.order}"
            
            # 3 is NOT a primitive root mod 101 (order is 100 actually)
            gear3 = SafeGear(101, 3)
            
            # For 65537, 3 is a primitive root
            gear_65537 = SafeGear(65537, 3)
            
            details = f"ord_101(2)={gear.order}, ord_101(3)={gear3.order}, ord_65537(3)={gear_65537.order}"
            return True, details
        
        def test_fermat_little_theorem():
            """Verify b^{p-1} â‰¡ 1 (mod p) for prime p."""
            primes = [7, 11, 101, 257, 65537]
            
            for p in primes:
                for b in [2, 3, 5]:
                    if gcd(b, p) == 1:
                        result = pow(b, p - 1, p)
                        if result != 1:
                            return False, f"{b}^{p-1} â‰¢ 1 (mod {p})"
            
            return True, "b^{p-1} â‰¡ 1 (mod p) verified"
        
        def test_composition_is_multiplication():
            """Verify composing gears multiplies bases."""
            m = 101
            
            gear2 = SafeGear(m, 2)
            gear3 = SafeGear(m, 3)
            
            # Composing wind_2 then wind_3 should be like wind_6
            for x in range(m):
                composed = gear3.wind(gear2.wind(x))
                expected = (6 * x) % m
                if composed != expected:
                    return False, f"Composition failed at {x}"
            
            return True, "wind_b1 âˆ˜ wind_b2 = wind_{b1Ã—b2}"
        
        def test_inverse_composition():
            """Verify unwind is the compositional inverse."""
            gear = SafeGear(65537, 2)
            
            for x in range(1000):
                # wind then unwind
                if gear.unwind(gear.wind(x)) != x:
                    return False, f"windâ»Â¹(wind(x)) â‰  x at {x}"
                # unwind then wind
                if gear.wind(gear.unwind(x)) != x:
                    return False, f"wind(windâ»Â¹(x)) â‰  x at {x}"
            
            return True, "unwind is the two-sided inverse of wind"
        
        self.test("Order Divides Totient", test_order_divides_totient, "Multiplicative")
        self.test("Primitive Root Detection", test_primitive_root_detection, "Multiplicative")
        self.test("Fermat's Little Theorem", test_fermat_little_theorem, "Multiplicative")
        self.test("Composition is Multiplication", test_composition_is_multiplication, "Multiplicative")
        self.test("Inverse Composition", test_inverse_composition, "Multiplicative")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 4: GEARBOX HOLOGRAPHY
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_gearbox_holography(self):
        """Test holographic properties of the gearbox."""
        print("\n" + "â•" * 70)
        print("ğŸŒŒ GEARBOX HOLOGRAPHY")
        print("â•" * 70)
        
        def test_projection_reconstruction():
            """Verify project â†’ reconstruct is identity."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            test_values = [0, 1, 42, 1000, 123456, gearbox.capacity - 1]
            for v in test_values:
                residues = gearbox.project(v)
                reconstructed = gearbox.reconstruct(residues)
                if reconstructed != v:
                    return False, f"Round-trip failed: {v} â†’ {reconstructed}"
            
            return True, "projectâ»Â¹(project(x)) = x"
        
        def test_encode_decode():
            """Verify encode â†’ decode with winding."""
            gearbox = HolographicGearbox(n_gears=10, k_threshold=6)
            
            test_values = [0, 1, 999, 12345, gearbox.capacity // 2]
            for v in test_values:
                encoded = gearbox.encode(v)
                decoded = gearbox.decode(encoded)
                if decoded != v:
                    return False, f"Encode/decode failed: {v} â†’ {decoded}"
            
            return True, "decode(encode(x)) = x with winding"
        
        def test_k_of_n_threshold():
            """Verify ANY k gears suffice for reconstruction."""
            gearbox = HolographicGearbox(n_gears=10, k_threshold=6)
            
            test_value = 123456
            encoded = gearbox.encode(test_value)
            
            # Test all C(10,6) = 210 combinations
            success_count = 0
            total_combos = 0
            
            for combo in combinations(range(10), 6):
                total_combos += 1
                residues = gearbox.unwind_all(encoded)
                try:
                    reconstructed = gearbox.reconstruct(residues, list(combo))
                    if reconstructed == test_value:
                        success_count += 1
                except:
                    pass
            
            if success_count != total_combos:
                return False, f"Only {success_count}/{total_combos} combinations worked"
            
            return True, f"All {total_combos} 6-of-10 combinations work"
        
        def test_threshold_failure_below_k():
            """Verify reconstruction fails with fewer than k gears."""
            gearbox = HolographicGearbox(n_gears=10, k_threshold=6)
            
            test_value = 42
            residues = gearbox.project(test_value)
            
            # Try with only 5 gears (should give wrong answer or fail)
            for combo in combinations(range(10), 5):
                try:
                    # This should work but give a different value
                    # (reconstruction is unique only for k or more)
                    partial_residues = [residues[i] for i in combo]
                    partial_moduli = [gearbox.moduli[i] for i in combo]
                    result = chinese_remainder_theorem(partial_residues, partial_moduli)
                    # Result will be in a smaller range
                    partial_capacity = reduce(lambda a, b: a * b, partial_moduli)
                    if result >= partial_capacity:
                        return False, "CRT gave out-of-range result"
                except:
                    pass
            
            return True, "k-1 gears insufficient for unique reconstruction"
        
        def test_holographic_distribution():
            """Verify information is distributed across all gears."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            test_value = 12345
            residues = gearbox.project(test_value)
            
            # Each residue should be different (high probability for random value)
            unique_residues = len(set(residues))
            
            # Verify that no single residue determines the value
            # (many values map to the same residue)
            candidates_per_gear = []
            for i, r in enumerate(residues):
                m = gearbox.moduli[i]
                # Count how many values in capacity have this residue
                count = gearbox.capacity // m
                if gearbox.capacity % m > r:
                    count += 1
                candidates_per_gear.append(count)
            
            details = f"Residues: {residues[:3]}..., Candidates per gear: {candidates_per_gear[:3]}..."
            return True, details
        
        self.test("Projection/Reconstruction", test_projection_reconstruction, "Holography")
        self.test("Encode/Decode with Winding", test_encode_decode, "Holography")
        self.test("k-of-n Threshold Property", test_k_of_n_threshold, "Holography")
        self.test("Below-k Failure", test_threshold_failure_below_k, "Holography")
        self.test("Holographic Distribution", test_holographic_distribution, "Holography")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 5: INFORMATION THEORY
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_information_theory(self):
        """Test information-theoretic properties."""
        print("\n" + "â•" * 70)
        print("ğŸ“Š INFORMATION THEORY")
        print("â•" * 70)
        
        def test_entropy_calculation():
            """Calculate and verify entropy properties."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            # Total entropy = log2(capacity)
            total_entropy = math.log2(gearbox.capacity)
            
            # Per-gear entropy
            per_gear_entropy = [math.log2(m) for m in gearbox.moduli]
            
            # Sum should exceed total (redundancy)
            sum_entropy = sum(per_gear_entropy)
            
            redundancy_ratio = sum_entropy / total_entropy
            
            details = f"Total: {total_entropy:.1f} bits, Sum: {sum_entropy:.1f} bits, Redundancy: {redundancy_ratio:.2f}x"
            
            if redundancy_ratio < 1:
                return False, "Redundancy ratio should be >= 1"
            
            return True, details
        
        def test_non_locality_index():
            """Calculate the non-locality index."""
            gearbox = HolographicGearbox(n_gears=10, k_threshold=6)
            
            # Non-locality: fraction of information NOT in any single gear
            per_gear_bits = [math.log2(m) for m in gearbox.moduli]
            total_bits = math.log2(gearbox.capacity)
            
            # Each gear reveals only log2(m_i) / log2(capacity) of info
            max_single_gear_fraction = max(per_gear_bits) / total_bits
            
            non_locality = 1 - max_single_gear_fraction
            
            details = f"Non-locality index: {non_locality*100:.1f}%"
            
            if non_locality < 0.5:
                return False, "Non-locality should be high"
            
            return True, details
        
        def test_mds_property():
            """Verify Maximum Distance Separable property."""
            gearbox = HolographicGearbox(n_gears=10, k_threshold=6)
            
            # MDS: distance d = n - k + 1
            n = gearbox.n_gears
            k = gearbox.k_threshold
            expected_distance = n - k + 1  # = 5
            
            # Can correct d-1 = 4 erasures
            test_value = 42
            encoded = gearbox.encode(test_value)
            
            # Try all ways to lose 4 gears
            losses_survived = 0
            total_tests = 0
            
            for erased in combinations(range(n), n - k):
                total_tests += 1
                available = [i for i in range(n) if i not in erased]
                
                try:
                    decoded = gearbox.decode(encoded, available)
                    if decoded == test_value:
                        losses_survived += 1
                except:
                    pass
            
            details = f"Survived {losses_survived}/{total_tests} {n-k}-erasure patterns"
            return losses_survived == total_tests, details
        
        def test_information_concentration():
            """Test how information is concentrated/distributed."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            # For a random value, each gear independently constrains the solution
            test_value = 123456
            residues = gearbox.project(test_value)
            
            # With each additional gear, solution space shrinks
            solution_spaces = []
            for k in range(1, gearbox.n_gears + 1):
                partial_moduli = gearbox.moduli[:k]
                space_size = reduce(lambda a, b: a * b, partial_moduli)
                solution_spaces.append(space_size)
            
            # Verify monotonic increase
            for i in range(len(solution_spaces) - 1):
                if solution_spaces[i] >= solution_spaces[i + 1]:
                    return False, "Solution space should grow"
            
            details = f"Space sizes: {[f'{s:.1e}' for s in solution_spaces[:4]]}..."
            return True, details
        
        def test_mutual_information():
            """Test mutual information between gears."""
            gearbox = HolographicGearbox(n_gears=5, k_threshold=3)
            
            # For coprime moduli, gears are statistically independent
            # I(X;Y) = H(X) + H(Y) - H(X,Y) = 0 for independent
            
            # Sample random values and check correlation
            samples = 1000
            residue_pairs = defaultdict(int)
            
            for _ in range(samples):
                v = random.randint(0, gearbox.capacity - 1)
                residues = gearbox.project(v)
                key = (residues[0], residues[1])
                residue_pairs[key] += 1
            
            # For independent uniform, all pairs should be equally likely
            expected_per_pair = samples / (gearbox.moduli[0] * gearbox.moduli[1])
            
            # Chi-squared-like test
            max_deviation = 0
            for pair, count in residue_pairs.items():
                deviation = abs(count - expected_per_pair) / max(expected_per_pair, 1)
                max_deviation = max(max_deviation, deviation)
            
            details = f"Max deviation from uniform: {max_deviation:.2f}"
            return max_deviation < 0.5, details
        
        self.test("Entropy Calculation", test_entropy_calculation, "InfoTheory")
        self.test("Non-Locality Index", test_non_locality_index, "InfoTheory")
        self.test("MDS Property", test_mds_property, "InfoTheory")
        self.test("Information Concentration", test_information_concentration, "InfoTheory")
        self.test("Mutual Information (Independence)", test_mutual_information, "InfoTheory")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 6: GAUGE STRUCTURE
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_gauge_structure(self):
        """Test gauge-theoretic properties of winding."""
        print("\n" + "â•" * 70)
        print("âš¡ GAUGE STRUCTURE")
        print("â•" * 70)
        
        def test_gauge_equivalence():
            """Verify wound values are gauge-equivalent to unwound."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            test_value = 12345
            residues = gearbox.project(test_value)
            wound = gearbox.wind_all(residues)
            
            # The wound and unwound representations are equivalent
            # They both reconstruct to the same value
            
            unwound = gearbox.unwind_all(wound)
            if unwound != residues:
                return False, "Unwind should restore residues"
            
            return True, "Wound and unwound are gauge-equivalent"
        
        def test_gauge_orbit():
            """Test the orbit under gauge transformations."""
            gear = SafeGear(101, 3)
            
            # For each x, the orbit under winding is its gauge orbit
            x = 42
            orbit = gear.orbit(x)
            
            # All orbit elements contain the same "physics"
            # (they all unwind to the same value under appropriate inverse)
            
            # Verify orbit is closed
            for elem in orbit:
                if gear.wind(elem) not in orbit:
                    return False, "Orbit not closed"
            
            # Verify we can unwind any orbit element back to x
            for i, elem in enumerate(orbit):
                unwound = gear.unwind_n(elem, i)
                if unwound != x:
                    return False, f"Unwinding {elem} by {i} didn't give {x}"
            
            details = f"Orbit of {x} has {len(orbit)} elements"
            return True, details
        
        def test_gauge_invariant():
            """Verify reconstruction is gauge-invariant."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            test_value = 42
            residues = gearbox.project(test_value)
            
            # Wind with different numbers of turns
            for turns in [0, 1, 5, 10, 100]:
                wound = [g.wind_n(r, turns) for g, r in zip(gearbox.gears, residues)]
                unwound = [g.unwind_n(w, turns) for g, w in zip(gearbox.gears, wound)]
                reconstructed = gearbox.reconstruct(unwound)
                
                if reconstructed != test_value:
                    return False, f"Failed after {turns} winds"
            
            return True, "Reconstruction is gauge-invariant"
        
        def test_parallel_transport():
            """Test parallel transport around a loop."""
            gear = SafeGear(101, 3)
            
            x = 17
            
            # Wind forward by order, should return to start
            transported = x
            for _ in range(gear.order):
                transported = gear.wind(transported)
            
            if transported != x:
                return False, f"Parallel transport: {x} â†’ {transported}"
            
            return True, f"x returns after {gear.order} parallel transports"
        
        def test_holonomy():
            """Test holonomy (non-trivial loops)."""
            gear = SafeGear(101, 3)
            
            # The holonomy group is generated by the winding transformation
            # For a single gear, it's cyclic of order = multiplicative order
            
            x = 1  # Generator of â„¤*_p
            
            holonomy_group = set()
            current = x
            while True:
                holonomy_group.add(current)
                current = gear.wind(current)
                if current == x:
                    break
            
            expected_size = gear.order
            actual_size = len(holonomy_group)
            
            if actual_size != expected_size:
                return False, f"Holonomy group size: {actual_size} vs {expected_size}"
            
            return True, f"Holonomy group has order {actual_size}"
        
        self.test("Gauge Equivalence", test_gauge_equivalence, "Gauge")
        self.test("Gauge Orbit", test_gauge_orbit, "Gauge")
        self.test("Gauge Invariance of Reconstruction", test_gauge_invariant, "Gauge")
        self.test("Parallel Transport", test_parallel_transport, "Gauge")
        self.test("Holonomy Group", test_holonomy, "Gauge")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 7: EDGE CASES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_edge_cases(self):
        """Test edge cases and boundary conditions."""
        print("\n" + "â•" * 70)
        print("ğŸ”² EDGE CASES")
        print("â•" * 70)
        
        def test_boundary_values():
            """Test at capacity boundaries."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            boundary_values = [
                0,
                1,
                gearbox.capacity - 1,
                gearbox.capacity // 2
            ]
            
            for v in boundary_values:
                encoded = gearbox.encode(v)
                decoded = gearbox.decode(encoded)
                if decoded != v:
                    return False, f"Boundary value {v} failed"
            
            return True, "All boundary values handled correctly"
        
        def test_small_moduli():
            """Test with very small prime moduli."""
            small_gearbox = HolographicGearbox(n_gears=5, k_threshold=3, prime_start=7)
            
            # Capacity will be small
            for v in range(min(100, small_gearbox.capacity)):
                encoded = small_gearbox.encode(v)
                decoded = small_gearbox.decode(encoded)
                if decoded != v:
                    return False, f"Small moduli failed at {v}"
            
            details = f"Tested all values up to {min(100, small_gearbox.capacity)}"
            return True, details
        
        def test_large_values():
            """Test with values near capacity limit."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            large_values = [
                gearbox.capacity - 1,
                gearbox.capacity - 100,
                gearbox.capacity - 10000
            ]
            
            for v in large_values:
                encoded = gearbox.encode(v)
                decoded = gearbox.decode(encoded)
                if decoded != v:
                    return False, f"Large value {v} failed"
            
            return True, f"Large values up to {gearbox.capacity-1} handled"
        
        def test_consecutive_values():
            """Test consecutive values for patterns."""
            gearbox = HolographicGearbox(n_gears=5, k_threshold=3)
            
            for start in [0, 100, 10000]:
                for v in range(start, start + 100):
                    if v >= gearbox.capacity:
                        break
                    encoded = gearbox.encode(v)
                    decoded = gearbox.decode(encoded)
                    if decoded != v:
                        return False, f"Consecutive value {v} failed"
            
            return True, "Consecutive values all pass"
        
        def test_minimum_k():
            """Test with minimum possible k."""
            # k=1 means single gear sufficient
            gearbox = HolographicGearbox(n_gears=5, k_threshold=1)
            
            # Capacity is just the smallest modulus
            for v in range(min(100, gearbox.capacity)):
                encoded = gearbox.encode(v)
                # Decode with just gear 0
                decoded = gearbox.decode(encoded, [0])
                if decoded != v:
                    return False, f"k=1 failed at {v}"
            
            return True, "k=1 case works"
        
        def test_k_equals_n():
            """Test with k=n (all gears required)."""
            gearbox = HolographicGearbox(n_gears=5, k_threshold=5)
            
            for v in range(min(100, gearbox.capacity)):
                encoded = gearbox.encode(v)
                # Must use all gears
                decoded = gearbox.decode(encoded, list(range(5)))
                if decoded != v:
                    return False, f"k=n failed at {v}"
            
            return True, "k=n case works"
        
        self.test("Boundary Values", test_boundary_values, "Edge")
        self.test("Small Moduli", test_small_moduli, "Edge")
        self.test("Large Values", test_large_values, "Edge")
        self.test("Consecutive Values", test_consecutive_values, "Edge")
        self.test("Minimum k (k=1)", test_minimum_k, "Edge")
        self.test("Maximum k (k=n)", test_k_equals_n, "Edge")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 8: STRESS TESTS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_stress(self):
        """Stress tests with high volume."""
        print("\n" + "â•" * 70)
        print("ğŸ’ª STRESS TESTS")
        print("â•" * 70)
        
        def test_volume_encode_decode():
            """High volume encode/decode."""
            gearbox = HolographicGearbox(n_gears=10, k_threshold=6)
            
            iterations = 1000
            failures = 0
            
            for _ in range(iterations):
                v = random.randint(0, gearbox.capacity - 1)
                encoded = gearbox.encode(v)
                
                # Random subset of k gears
                available = random.sample(range(10), 6)
                decoded = gearbox.decode(encoded, available)
                
                if decoded != v:
                    failures += 1
            
            if failures > 0:
                return False, f"{failures}/{iterations} failures"
            
            return True, f"{iterations} encode/decode cycles, 0 failures"
        
        def test_all_combinations():
            """Test all k-combinations for multiple values."""
            gearbox = HolographicGearbox(n_gears=7, k_threshold=4)
            
            test_values = [random.randint(0, gearbox.capacity - 1) for _ in range(10)]
            total_tests = 0
            failures = 0
            
            for v in test_values:
                encoded = gearbox.encode(v)
                residues = gearbox.unwind_all(encoded)
                
                for combo in combinations(range(7), 4):
                    total_tests += 1
                    reconstructed = gearbox.reconstruct(residues, list(combo))
                    if reconstructed != v:
                        failures += 1
            
            details = f"{total_tests} total tests, {failures} failures"
            return failures == 0, details
        
        def test_rapid_wind_unwind():
            """Rapid winding and unwinding cycles."""
            gear = SafeGear(65537, 2)
            
            iterations = 10000
            x = 42
            
            for _ in range(iterations):
                n = random.randint(1, 1000)
                wound = gear.wind_n(x, n)
                unwound = gear.unwind_n(wound, n)
                if unwound != x:
                    return False, f"Failed at n={n}"
            
            return True, f"{iterations} rapid wind/unwind cycles"
        
        def test_mixed_operations():
            """Mixed operations stress test."""
            gearbox = HolographicGearbox(n_gears=10, k_threshold=6)
            
            operations = 500
            failures = 0
            
            for _ in range(operations):
                v = random.randint(0, gearbox.capacity - 1)
                
                # Encode
                encoded = gearbox.encode(v)
                
                # Random extra winds
                extra_winds = random.randint(0, 10)
                for _ in range(extra_winds):
                    encoded = gearbox.wind_all(encoded)
                
                # Unwind same amount
                for _ in range(extra_winds):
                    encoded = gearbox.unwind_all(encoded)
                
                # Decode
                decoded = gearbox.decode(encoded)
                
                if decoded != v:
                    failures += 1
            
            return failures == 0, f"{operations} mixed operations, {failures} failures"
        
        self.test("Volume Encode/Decode (1000x)", test_volume_encode_decode, "Stress")
        self.test("All k-Combinations", test_all_combinations, "Stress")
        self.test("Rapid Wind/Unwind (10000x)", test_rapid_wind_unwind, "Stress")
        self.test("Mixed Operations (500x)", test_mixed_operations, "Stress")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TEST CATEGORY 9: MATHEMATICAL IDENTITIES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def test_mathematical_identities(self):
        """Test mathematical identities and theorems."""
        print("\n" + "â•" * 70)
        print("ğŸ“ MATHEMATICAL IDENTITIES")
        print("â•" * 70)
        
        def test_crt_uniqueness():
            """Verify CRT solution uniqueness."""
            moduli = [7, 11, 13]
            M = reduce(lambda a, b: a * b, moduli)
            
            # Every combination of residues gives unique solution
            seen = set()
            for r0 in range(moduli[0]):
                for r1 in range(moduli[1]):
                    for r2 in range(moduli[2]):
                        x = chinese_remainder_theorem([r0, r1, r2], moduli)
                        if x in seen:
                            return False, f"Duplicate: {x}"
                        seen.add(x)
            
            if len(seen) != M:
                return False, f"Expected {M} unique, got {len(seen)}"
            
            return True, f"All {M} solutions unique"
        
        def test_euler_theorem():
            """Verify Euler's theorem: a^Ï†(n) â‰¡ 1 (mod n)."""
            test_cases = [(7, 2), (15, 4), (101, 3), (65537, 2)]
            
            for n, a in test_cases:
                if gcd(a, n) != 1:
                    continue
                phi = euler_totient(n)
                result = pow(a, phi, n)
                if result != 1:
                    return False, f"a^Ï†(n) â‰  1 for a={a}, n={n}"
            
            return True, "a^Ï†(n) â‰¡ 1 (mod n) verified"
        
        def test_order_divisibility():
            """Verify ord(a^k) = ord(a) / gcd(k, ord(a))."""
            gear = SafeGear(101, 3)
            ord_a = gear.order
            
            for k in [2, 3, 5, 10]:
                a_k = pow(gear.base, k, gear.modulus)
                gear_k = SafeGear(gear.modulus, a_k)
                
                expected = ord_a // gcd(k, ord_a)
                actual = gear_k.order
                
                if actual != expected:
                    return False, f"ord(a^{k}) = {actual} â‰  {expected}"
            
            return True, "ord(a^k) = ord(a)/gcd(k, ord(a))"
        
        def test_multiplicative_group_size():
            """Verify |â„¤*_n| = Ï†(n)."""
            for n in [7, 12, 15, 100, 101]:
                phi = euler_totient(n)
                
                # Count invertible elements
                invertible = sum(1 for a in range(1, n) if gcd(a, n) == 1)
                
                if invertible != phi:
                    return False, f"|â„¤*_{n}| = {invertible} â‰  Ï†({n}) = {phi}"
            
            return True, "|â„¤*_n| = Ï†(n) verified"
        
        def test_lagrange_theorem():
            """Verify orbit lengths divide group order (Lagrange)."""
            gear = SafeGear(101, 3)
            
            # Group order is Ï†(101) = 100 for â„¤*_101
            # But winding acts on all of â„¤_101
            
            # For x â‰  0, orbit length = multiplicative order of base
            for x in range(1, 101):
                orbit_len = len(gear.orbit(x))
                if gear.order % orbit_len != 0:
                    return False, f"Orbit length {orbit_len} doesn't divide {gear.order}"
            
            return True, "Orbit lengths divide group order"
        
        self.test("CRT Uniqueness", test_crt_uniqueness, "Math")
        self.test("Euler's Theorem", test_euler_theorem, "Math")
        self.test("Order Divisibility", test_order_divisibility, "Math")
        self.test("Multiplicative Group Size", test_multiplicative_group_size, "Math")
        self.test("Lagrange's Theorem", test_lagrange_theorem, "Math")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SUMMARY
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def print_summary(self):
        """Print test summary."""
        total = self.results['passed'] + self.results['failed']
        
        print("\n" + "â•" * 80)
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                                      â•‘
â•‘   ğŸŒªï¸ğŸ’œ HOLOGRAPHIC GEARBOX TEST RESULTS ğŸ’œğŸŒªï¸                                                        â•‘
â•‘                                                                                                      â•‘
â•‘   Tests Passed: {self.results['passed']:3d}                                                                           â•‘
â•‘   Tests Failed: {self.results['failed']:3d}                                                                           â•‘
â•‘   Total Tests:  {total:3d}                                                                           â•‘
â•‘   Success Rate: {100*self.results['passed']/total if total > 0 else 0:5.1f}%                                                                       â•‘
â•‘                                                                                                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                                                      â•‘
â•‘   CATEGORIES TESTED:                                                                                 â•‘
â•‘   ğŸ”§ SafeGear Fundamentals    - Bijection, inverse, coprimality                                      â•‘
â•‘   ğŸŒ€ Winding Dynamics         - Orbits, closure, return                                              â•‘
â•‘   âœ–ï¸ Multiplicative Structure - Orders, primitive roots, Fermat                                      â•‘
â•‘   ğŸŒŒ Gearbox Holography       - Projection, reconstruction, k-of-n                                   â•‘
â•‘   ğŸ“Š Information Theory       - Entropy, non-locality, MDS                                           â•‘
â•‘   âš¡ Gauge Structure          - Equivalence, orbits, holonomy                                        â•‘
â•‘   ğŸ”² Edge Cases               - Boundaries, small/large values                                       â•‘
â•‘   ğŸ’ª Stress Tests             - Volume, combinations, rapid ops                                      â•‘
â•‘   ğŸ“ Mathematical Identities  - CRT, Euler, Lagrange                                                 â•‘
â•‘                                                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
        
        # Category breakdown
        categories = defaultdict(lambda: {'passed': 0, 'failed': 0})
        for test in self.results['tests']:
            cat = test.get('category', 'General')
            if test['passed']:
                categories[cat]['passed'] += 1
            else:
                categories[cat]['failed'] += 1
        
        print("\nCategory Breakdown:")
        for cat, stats in sorted(categories.items()):
            total_cat = stats['passed'] + stats['failed']
            pct = 100 * stats['passed'] / total_cat if total_cat > 0 else 0
            status = "âœ…" if stats['failed'] == 0 else "âš ï¸"
            print(f"  {status} {cat}: {stats['passed']}/{total_cat} ({pct:.0f}%)")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    suite = GearboxTestSuite()
    suite.run_all()
    
    print("\n" + "ğŸŒªï¸ğŸ’œ" * 30)
    print("\n   THE HYPERMORPHIC HOLOGRAPHIC GEARBOX IS FULLY VERIFIED")
    print("\n" + "ğŸŒªï¸ğŸ’œ" * 30)
