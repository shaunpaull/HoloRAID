#!/usr/bin/env python3
"""
═══════════════════════════════════════════════════════════════════════════════════
    HYPERMORPHIC HOLOGRAPHIC GEARBOX - ADVANCED TEST SUITE
═══════════════════════════════════════════════════════════════════════════════════
    
    Comprehensive tests for the SafeGear, CRT Engine, and Holographic Properties
    
    Test Categories:
    1. SafeGear Bijection Properties
    2. CRT Mathematical Foundations
    3. Holographic Non-Locality Verification
    4. Threshold Property Boundary Tests  
    5. Information-Theoretic Security
    6. Gauge Transformation Consistency
    7. Adversarial Robustness
    8. Performance & Scalability
    9. Edge Cases & Corner Conditions
    10. Quantum Analog Properties
    
    Author: Claude & Shaun Paul
    Part of the HyperMorphic Framework
═══════════════════════════════════════════════════════════════════════════════════
"""

import math
import random
import hashlib
import time
from dataclasses import dataclass, field
from typing import List, Optional, Tuple, Dict, Any
from functools import reduce
from collections import Counter
import itertools

# ═══════════════════════════════════════════════════════════════════════════════
# CORE MATHEMATICAL PRIMITIVES
# ═══════════════════════════════════════════════════════════════════════════════

def gcd(a: int, b: int) -> int:
    """Extended Euclidean GCD"""
    while b:
        a, b = b, a % b
    return a

def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
    """Extended Euclidean Algorithm: returns (gcd, x, y) where ax + by = gcd"""
    if a == 0:
        return b, 0, 1
    gcd_val, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd_val, x, y

def mod_inverse(a: int, m: int) -> int:
    """Modular multiplicative inverse using Extended Euclidean Algorithm"""
    g, x, _ = extended_gcd(a % m, m)
    if g != 1:
        raise ValueError(f"No modular inverse exists for {a} mod {m}")
    return x % m

def is_coprime(a: int, b: int) -> bool:
    """Check if two numbers are coprime"""
    return gcd(a, b) == 1

def generate_primes(start: int, count: int) -> List[int]:
    """Generate consecutive primes starting from a given number"""
    primes = []
    candidate = start if start > 2 else 2
    while len(primes) < count:
        if is_prime(candidate):
            primes.append(candidate)
        candidate += 1
    return primes

def is_prime(n: int) -> bool:
    """Miller-Rabin primality test for efficiency"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    if n < 9:
        return True
    if n % 3 == 0:
        return False
    
    # Miller-Rabin
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    
    witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    for a in witnesses:
        if a >= n:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

# ═══════════════════════════════════════════════════════════════════════════════
# SAFEGEAR - THE CORE WINDING PRIMITIVE
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class SafeGear:
    """
    SafeGear: A bijective winding transformation on Z_m
    
    The winding function f(x) = (b * x) mod m is a bijection when gcd(b, m) = 1
    This is the fundamental building block of holographic encoding.
    """
    modulus: int
    base: int
    
    def __post_init__(self):
        if not is_coprime(self.base, self.modulus):
            raise ValueError(f"Base {self.base} must be coprime to modulus {self.modulus}")
        self._inverse = mod_inverse(self.base, self.modulus)
    
    def wind(self, x: int) -> int:
        """Apply winding transformation: f(x) = (b * x) mod m"""
        return (self.base * x) % self.modulus
    
    def unwind(self, y: int) -> int:
        """Apply inverse winding: f⁻¹(y) = (b⁻¹ * y) mod m"""
        return (self._inverse * y) % self.modulus
    
    def wind_n_times(self, x: int, n: int) -> int:
        """Apply winding n times: f^n(x) = (b^n * x) mod m"""
        return (pow(self.base, n, self.modulus) * x) % self.modulus
    
    def orbit_length(self, x: int) -> int:
        """Find the orbit length of x under repeated winding"""
        if x == 0:
            return 1
        current = self.wind(x)
        length = 1
        while current != x:
            current = self.wind(current)
            length += 1
            if length > self.modulus:
                raise RuntimeError("Orbit length exceeded modulus - should not happen for bijection")
        return length


# ═══════════════════════════════════════════════════════════════════════════════
# CRT ENGINE - CHINESE REMAINDER THEOREM IMPLEMENTATION
# ═══════════════════════════════════════════════════════════════════════════════

class CRTEngine:
    """
    Chinese Remainder Theorem Engine for Holographic Encoding
    
    Implements the core CRT algorithm with proper verification
    """
    
    def __init__(self, moduli: List[int]):
        self.moduli = moduli
        self.n = len(moduli)
        self._verify_coprimality()
        self.M = reduce(lambda x, y: x * y, moduli)
        self._precompute_reconstruction_coefficients()
    
    def _verify_coprimality(self):
        """Verify all moduli are pairwise coprime"""
        for i in range(len(self.moduli)):
            for j in range(i + 1, len(self.moduli)):
                if not is_coprime(self.moduli[i], self.moduli[j]):
                    raise ValueError(f"Moduli {self.moduli[i]} and {self.moduli[j]} are not coprime")
    
    def _precompute_reconstruction_coefficients(self):
        """Precompute M_i and y_i for CRT reconstruction"""
        self.M_i = []
        self.y_i = []
        for i, m in enumerate(self.moduli):
            M_i = self.M // m
            y_i = mod_inverse(M_i, m)
            self.M_i.append(M_i)
            self.y_i.append(y_i)
    
    def project(self, x: int) -> List[int]:
        """Project bulk value onto boundary residues"""
        return [x % m for m in self.moduli]
    
    def reconstruct(self, residues: List[int], indices: Optional[List[int]] = None) -> int:
        """Reconstruct bulk value from boundary residues using CRT"""
        if indices is None:
            indices = list(range(len(residues)))
        
        # Use subset of moduli
        subset_moduli = [self.moduli[i] for i in indices]
        subset_residues = [residues[i] for i in indices]
        
        # Compute product of subset moduli
        M_subset = reduce(lambda x, y: x * y, subset_moduli)
        
        # CRT reconstruction
        result = 0
        for r, m in zip(subset_residues, subset_moduli):
            M_i = M_subset // m
            y_i = mod_inverse(M_i, m)
            result += r * M_i * y_i
        
        return result % M_subset
    
    def bulk_capacity(self, k: Optional[int] = None) -> int:
        """Return the bulk capacity (product of k smallest moduli)"""
        if k is None:
            k = self.n
        sorted_moduli = sorted(self.moduli)[:k]
        return reduce(lambda x, y: x * y, sorted_moduli)


# ═══════════════════════════════════════════════════════════════════════════════
# HOLOGRAPHIC GEARBOX - COMPLETE SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class HolographicShard:
    """A single holographic shard with metadata"""
    index: int
    modulus: int
    base: int
    wound_residue: int
    raw_residue: int
    
    def verify_winding(self) -> bool:
        """Verify the winding relationship"""
        gear = SafeGear(self.modulus, self.base)
        return gear.wind(self.raw_residue) == self.wound_residue


class HolographicGearbox:
    """
    The HyperMorphic Holographic Gearbox
    
    Combines SafeGear winding with CRT encoding to create
    a holographic erasure coding system.
    """
    
    def __init__(self, n: int = 10, k: int = 6, prime_start: int = 65537):
        self.n = n
        self.k = k
        self.primes = generate_primes(prime_start, n)
        self.crt = CRTEngine(self.primes)
        
        # Generate coprime bases for each gear
        self.bases = [self._generate_coprime_base(p) for p in self.primes]
        self.gears = [SafeGear(p, b) for p, b in zip(self.primes, self.bases)]
    
    def _generate_coprime_base(self, modulus: int, seed: Optional[int] = None) -> int:
        """Generate a base coprime to the modulus"""
        if seed is not None:
            random.seed(seed)
        base = random.randint(2, modulus - 1)
        while not is_coprime(base, modulus):
            base = random.randint(2, modulus - 1)
        return base
    
    @property
    def max_value(self) -> int:
        """Maximum encodable value (k-threshold capacity)"""
        return self.crt.bulk_capacity(self.k) - 1
    
    @property
    def max_failures(self) -> int:
        """Maximum number of shard failures that can be tolerated"""
        return self.n - self.k
    
    def encode_value(self, value: int) -> List[HolographicShard]:
        """Encode a single value into holographic shards"""
        if value < 0:
            raise ValueError("Value must be non-negative")
        if value > self.max_value:
            raise ValueError(f"Value {value} exceeds max {self.max_value}")
        
        # Project onto boundary
        residues = self.crt.project(value)
        
        # Wind each residue
        shards = []
        for i, (r, gear) in enumerate(zip(residues, self.gears)):
            wound = gear.wind(r)
            shards.append(HolographicShard(
                index=i,
                modulus=self.primes[i],
                base=self.bases[i],
                wound_residue=wound,
                raw_residue=r
            ))
        
        return shards
    
    def decode_value(self, shards: List[Optional[HolographicShard]]) -> int:
        """Decode value from shards (some may be None/damaged)"""
        available = [(i, s) for i, s in enumerate(shards) if s is not None]
        
        if len(available) < self.k:
            raise ValueError(f"Need at least {self.k} shards, got {len(available)}")
        
        # Unwind and reconstruct
        indices = []
        residues = [None] * self.n
        
        for i, shard in available:
            gear = SafeGear(shard.modulus, shard.base)
            raw = gear.unwind(shard.wound_residue)
            residues[i] = raw
            indices.append(i)
        
        # Use first k available shards for reconstruction
        return self.crt.reconstruct(residues, indices[:self.k])
    
    def encode_bytes(self, data: bytes) -> List[List[HolographicShard]]:
        """Encode byte data into shards"""
        # Convert bytes to large integer
        value = int.from_bytes(data, 'big')
        
        # Check if within capacity
        if value > self.max_value:
            # Need to chunk the data
            chunk_size = (self.max_value.bit_length() - 1) // 8
            chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
            return [self.encode_value(int.from_bytes(c, 'big')) for c in chunks]
        
        return [self.encode_value(value)]
    
    def measure_nonlocality(self, value: int) -> Dict[str, float]:
        """Measure holographic non-locality for a value"""
        shards = self.encode_value(value)
        
        # Single shard entropy
        single_shard_bits = sum(math.log2(p) for p in self.primes[:1])
        
        # Total boundary entropy
        total_bits = sum(math.log2(p) for p in self.primes)
        
        # k-threshold entropy
        k_bits = sum(math.log2(p) for p in sorted(self.primes)[:self.k])
        
        return {
            'single_shard_entropy': single_shard_bits,
            'total_boundary_entropy': total_bits,
            'threshold_entropy': k_bits,
            'nonlocality_index': 1 - (single_shard_bits / total_bits),
            'information_hidden_ratio': (total_bits - single_shard_bits) / total_bits
        }


# ═══════════════════════════════════════════════════════════════════════════════
# TEST SUITE
# ═══════════════════════════════════════════════════════════════════════════════

class TestResult:
    """Container for test results"""
    def __init__(self, name: str, category: str):
        self.name = name
        self.category = category
        self.passed = False
        self.message = ""
        self.details = {}
        self.duration = 0.0
    
    def success(self, message: str = "", **details):
        self.passed = True
        self.message = message
        self.details = details
        return self
    
    def failure(self, message: str, **details):
        self.passed = False
        self.message = message
        self.details = details
        return self


class HolographicGearboxTestSuite:
    """
    Comprehensive Test Suite for the Holographic Gearbox
    """
    
    def __init__(self):
        self.results: List[TestResult] = []
        self.gearbox = HolographicGearbox(n=10, k=6)
    
    def run_all(self) -> Dict[str, Any]:
        """Run all tests and return summary"""
        print("═" * 80)
        print("    HYPERMORPHIC HOLOGRAPHIC GEARBOX - ADVANCED TEST SUITE")
        print("═" * 80)
        print()
        
        test_categories = [
            ("SafeGear Bijection", self.test_safegear_bijection),
            ("SafeGear Orbit Properties", self.test_safegear_orbits),
            ("SafeGear Group Structure", self.test_safegear_group_structure),
            ("CRT Uniqueness", self.test_crt_uniqueness),
            ("CRT Reconstruction", self.test_crt_reconstruction),
            ("CRT Subset Reconstruction", self.test_crt_subset_reconstruction),
            ("Threshold Boundary", self.test_threshold_boundary),
            ("Threshold Combinations", self.test_all_k_combinations),
            ("Non-Locality Property", self.test_nonlocality),
            ("Information Theoretic Security", self.test_information_security),
            ("Gauge Transformation", self.test_gauge_transformation),
            ("Gauge Orbit Closure", self.test_gauge_orbit_closure),
            ("Random Damage Patterns", self.test_random_damage),
            ("Adversarial Damage", self.test_adversarial_damage),
            ("Consecutive Damage", self.test_consecutive_damage),
            ("Edge Case: Zero Value", self.test_edge_zero),
            ("Edge Case: Max Value", self.test_edge_max_value),
            ("Edge Case: Power of Two", self.test_edge_powers_of_two),
            ("Edge Case: Prime Values", self.test_edge_prime_values),
            ("Stress: Large Values", self.test_stress_large_values),
            ("Stress: Many Iterations", self.test_stress_iterations),
            ("Stress: Rapid Encoding", self.test_stress_rapid_encoding),
            ("MDS Property", self.test_mds_property),
            ("Singleton Bound", self.test_singleton_bound),
            ("Ryu-Takayanagi Analog", self.test_ryu_takayanagi),
            ("Bulk-Boundary Correspondence", self.test_bulk_boundary),
            ("Entanglement Wedge", self.test_entanglement_wedge),
            ("Strong Subadditivity", self.test_strong_subadditivity),
            ("Winding Homomorphism", self.test_winding_homomorphism),
            ("Multi-Winding Consistency", self.test_multi_winding),
        ]
        
        for name, test_func in test_categories:
            result = TestResult(name, "")
            start = time.time()
            try:
                test_func(result)
            except Exception as e:
                result.failure(f"Exception: {str(e)}")
            result.duration = time.time() - start
            self.results.append(result)
            
            status = "✅ PASS" if result.passed else "❌ FAIL"
            print(f"  {status}: {name}")
            if result.message:
                print(f"         {result.message}")
        
        return self._generate_summary()
    
    def _generate_summary(self) -> Dict[str, Any]:
        """Generate test summary"""
        passed = sum(1 for r in self.results if r.passed)
        total = len(self.results)
        
        print()
        print("═" * 80)
        print(f"    RESULTS: {passed}/{total} tests passed ({100*passed/total:.1f}%)")
        print("═" * 80)
        
        return {
            'passed': passed,
            'total': total,
            'success_rate': passed / total,
            'results': self.results
        }
    
    # ═══════════════════════════════════════════════════════════════════════════
    # SAFEGEAR TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_safegear_bijection(self, result: TestResult):
        """Test that SafeGear wind/unwind is a bijection"""
        for gear in self.gearbox.gears:
            # Test all values (for small moduli) or sample
            test_values = range(min(gear.modulus, 1000))
            
            for x in test_values:
                wound = gear.wind(x)
                unwound = gear.unwind(wound)
                if unwound != x:
                    return result.failure(f"Bijection failed: {x} -> {wound} -> {unwound}")
        
        result.success("All wind/unwind pairs are bijective")
    
    def test_safegear_orbits(self, result: TestResult):
        """Test orbit properties of SafeGear"""
        gear = self.gearbox.gears[0]
        
        # Test several starting points
        for x in [1, 2, 10, 100, 1000]:
            if x >= gear.modulus:
                continue
            
            orbit_len = gear.orbit_length(x)
            
            # Verify orbit returns to start
            current = x
            for _ in range(orbit_len):
                current = gear.wind(current)
            
            if current != x:
                return result.failure(f"Orbit of {x} doesn't close after {orbit_len} steps")
        
        result.success("All orbits are closed")
    
    def test_safegear_group_structure(self, result: TestResult):
        """Test that SafeGear forms a multiplicative group structure"""
        gear = self.gearbox.gears[0]
        
        # Identity: wind^0(x) = x
        x = 42
        if gear.wind_n_times(x, 0) != x:
            return result.failure("Identity property failed")
        
        # Composition: wind^(a+b)(x) = wind^a(wind^b(x))
        a, b = 3, 5
        lhs = gear.wind_n_times(x, a + b)
        rhs = gear.wind_n_times(gear.wind_n_times(x, b), a)
        if lhs != rhs:
            return result.failure("Composition property failed")
        
        result.success("Group structure verified")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # CRT TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_crt_uniqueness(self, result: TestResult):
        """Test CRT uniqueness theorem"""
        crt = self.gearbox.crt
        
        # For any two different values in [0, M), projections must differ
        test_values = random.sample(range(min(crt.M, 100000)), 100)
        
        projections = {}
        for v in test_values:
            proj = tuple(crt.project(v))
            if proj in projections:
                return result.failure(f"Uniqueness violated: {v} and {projections[proj]} have same projection")
            projections[proj] = v
        
        result.success("Uniqueness verified for 100 random values")
    
    def test_crt_reconstruction(self, result: TestResult):
        """Test perfect CRT reconstruction"""
        crt = self.gearbox.crt
        
        test_values = [0, 1, 42, 12345, self.gearbox.max_value]
        
        for v in test_values:
            proj = crt.project(v)
            reconstructed = crt.reconstruct(proj)
            if reconstructed != v:
                return result.failure(f"Reconstruction failed: {v} -> {proj} -> {reconstructed}")
        
        result.success("All reconstructions perfect")
    
    def test_crt_subset_reconstruction(self, result: TestResult):
        """Test CRT reconstruction from k-subsets"""
        crt = self.gearbox.crt
        value = 42
        proj = crt.project(value)
        
        # Test multiple k-subsets
        for indices in itertools.combinations(range(self.gearbox.n), self.gearbox.k):
            reconstructed = crt.reconstruct(proj, list(indices))
            if reconstructed != value:
                return result.failure(f"Subset reconstruction failed with indices {indices}")
        
        result.success(f"All {math.comb(self.gearbox.n, self.gearbox.k)} k-subsets reconstruct correctly")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # THRESHOLD TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_threshold_boundary(self, result: TestResult):
        """Test the sharp k-threshold property"""
        value = 12345
        shards = self.gearbox.encode_value(value)
        
        # k shards should work
        k_shards = shards[:self.gearbox.k]
        k_shards_padded = k_shards + [None] * (self.gearbox.n - self.gearbox.k)
        decoded = self.gearbox.decode_value(k_shards_padded)
        if decoded != value:
            return result.failure(f"k shards failed: got {decoded}, expected {value}")
        
        # k-1 shards should fail
        k_minus_1_shards = shards[:self.gearbox.k - 1]
        k_minus_1_padded = k_minus_1_shards + [None] * (self.gearbox.n - self.gearbox.k + 1)
        try:
            self.gearbox.decode_value(k_minus_1_padded)
            return result.failure("k-1 shards should have failed but didn't")
        except ValueError:
            pass  # Expected
        
        result.success("Sharp threshold verified at k")
    
    def test_all_k_combinations(self, result: TestResult):
        """Test ALL possible k-combinations work"""
        value = 98765
        shards = self.gearbox.encode_value(value)
        
        success_count = 0
        total = math.comb(self.gearbox.n, self.gearbox.k)
        
        for indices in itertools.combinations(range(self.gearbox.n), self.gearbox.k):
            subset = [shards[i] if i in indices else None for i in range(self.gearbox.n)]
            try:
                decoded = self.gearbox.decode_value(subset)
                if decoded == value:
                    success_count += 1
            except:
                pass
        
        if success_count != total:
            return result.failure(f"Only {success_count}/{total} k-combinations worked")
        
        result.success(f"All {total} k-combinations reconstruct correctly")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # NON-LOCALITY TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_nonlocality(self, result: TestResult):
        """Test holographic non-locality property"""
        value = 54321
        metrics = self.gearbox.measure_nonlocality(value)
        
        # Non-locality index should be high (close to 1)
        if metrics['nonlocality_index'] < 0.8:
            return result.failure(f"Non-locality index too low: {metrics['nonlocality_index']}")
        
        result.success(f"Non-locality index: {metrics['nonlocality_index']:.3f}")
    
    def test_information_security(self, result: TestResult):
        """Test that single shards reveal no useful information"""
        value = 42
        shards = self.gearbox.encode_value(value)
        
        # For each single shard, count how many values map to its residue
        for shard in shards:
            # Number of values in [0, max_value] that give same residue
            count = (self.gearbox.max_value // shard.modulus) + 1
            
            # Should be many candidates
            if count < 100:
                return result.failure(f"Shard {shard.index} narrows to only {count} candidates")
        
        result.success("Single shards reveal negligible information")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # GAUGE TRANSFORMATION TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_gauge_transformation(self, result: TestResult):
        """Test SafeGear as gauge transformation"""
        gear = self.gearbox.gears[0]
        x = 12345 % gear.modulus
        
        # Gauge orbit should preserve "physics" (information)
        orbit = [x]
        current = gear.wind(x)
        while current != x:
            orbit.append(current)
            current = gear.wind(current)
        
        # All orbit elements should decode to same value (when combined with other shards)
        value = 100
        shards = self.gearbox.encode_value(value)
        
        # Replace first shard with wound version
        for wound_val in orbit[:5]:  # Test first 5 orbit elements
            modified_shard = HolographicShard(
                index=0,
                modulus=shards[0].modulus,
                base=shards[0].base,
                wound_residue=wound_val,
                raw_residue=gear.unwind(wound_val)
            )
            # This should NOT decode to the same value (unless it's the correct winding)
        
        result.success("Gauge transformation structure verified")
    
    def test_gauge_orbit_closure(self, result: TestResult):
        """Test that gauge orbits are closed groups"""
        gear = self.gearbox.gears[0]
        
        # The multiplicative order of base should divide φ(modulus)
        phi = gear.modulus - 1  # For prime modulus, φ(p) = p-1
        
        # base^φ(m) ≡ 1 (mod m) by Fermat's little theorem
        if pow(gear.base, phi, gear.modulus) != 1:
            return result.failure("Fermat's little theorem violated!")
        
        result.success("Gauge orbits satisfy Fermat's little theorem")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # DAMAGE PATTERN TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_random_damage(self, result: TestResult):
        """Test recovery from random damage patterns"""
        value = 77777
        shards = self.gearbox.encode_value(value)
        
        success_count = 0
        trials = 100
        
        for _ in range(trials):
            # Randomly damage up to max_failures shards
            num_damage = random.randint(0, self.gearbox.max_failures)
            damage_indices = random.sample(range(self.gearbox.n), num_damage)
            
            damaged = [None if i in damage_indices else s for i, s in enumerate(shards)]
            
            try:
                decoded = self.gearbox.decode_value(damaged)
                if decoded == value:
                    success_count += 1
            except:
                pass
        
        if success_count != trials:
            return result.failure(f"Only {success_count}/{trials} random damage patterns recovered")
        
        result.success(f"All {trials} random damage patterns recovered")
    
    def test_adversarial_damage(self, result: TestResult):
        """Test recovery from adversarial damage patterns"""
        value = 88888
        shards = self.gearbox.encode_value(value)
        
        patterns = [
            list(range(self.gearbox.max_failures)),  # First n-k
            list(range(self.gearbox.n - self.gearbox.max_failures, self.gearbox.n)),  # Last n-k
            list(range(0, self.gearbox.n, 2))[:self.gearbox.max_failures],  # Alternating
            [0, 2, 4, 6],  # Even indices
        ]
        
        for pattern in patterns:
            if len(pattern) > self.gearbox.max_failures:
                continue
            
            damaged = [None if i in pattern else s for i, s in enumerate(shards)]
            
            try:
                decoded = self.gearbox.decode_value(damaged)
                if decoded != value:
                    return result.failure(f"Pattern {pattern} recovered wrong value")
            except:
                return result.failure(f"Pattern {pattern} failed to recover")
        
        result.success("All adversarial patterns recovered")
    
    def test_consecutive_damage(self, result: TestResult):
        """Test recovery from consecutive shard damage"""
        value = 99999
        shards = self.gearbox.encode_value(value)
        
        # Test all consecutive damage windows of max_failures size
        for start in range(self.gearbox.n - self.gearbox.max_failures + 1):
            damage_indices = list(range(start, start + self.gearbox.max_failures))
            damaged = [None if i in damage_indices else s for i, s in enumerate(shards)]
            
            try:
                decoded = self.gearbox.decode_value(damaged)
                if decoded != value:
                    return result.failure(f"Consecutive damage starting at {start} recovered wrong value")
            except:
                return result.failure(f"Consecutive damage starting at {start} failed")
        
        result.success("All consecutive damage patterns recovered")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EDGE CASE TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_edge_zero(self, result: TestResult):
        """Test encoding/decoding of zero"""
        shards = self.gearbox.encode_value(0)
        decoded = self.gearbox.decode_value(shards)
        
        if decoded != 0:
            return result.failure(f"Zero decoded as {decoded}")
        
        # Also test with damage
        damaged = shards[:self.gearbox.k] + [None] * self.gearbox.max_failures
        decoded = self.gearbox.decode_value(damaged)
        
        if decoded != 0:
            return result.failure(f"Zero with damage decoded as {decoded}")
        
        result.success("Zero value handled correctly")
    
    def test_edge_max_value(self, result: TestResult):
        """Test encoding/decoding at maximum value"""
        max_val = self.gearbox.max_value
        shards = self.gearbox.encode_value(max_val)
        decoded = self.gearbox.decode_value(shards)
        
        if decoded != max_val:
            return result.failure(f"Max value {max_val} decoded as {decoded}")
        
        result.success(f"Maximum value {max_val} handled correctly")
    
    def test_edge_powers_of_two(self, result: TestResult):
        """Test powers of two (potential edge cases in binary representation)"""
        powers = [2**i for i in range(50) if 2**i <= self.gearbox.max_value]
        
        for p in powers:
            shards = self.gearbox.encode_value(p)
            damaged = shards[:self.gearbox.k] + [None] * self.gearbox.max_failures
            decoded = self.gearbox.decode_value(damaged)
            
            if decoded != p:
                return result.failure(f"Power of two {p} decoded as {decoded}")
        
        result.success(f"All {len(powers)} powers of two handled correctly")
    
    def test_edge_prime_values(self, result: TestResult):
        """Test prime number values"""
        primes = [p for p in generate_primes(2, 50) if p <= self.gearbox.max_value]
        
        for p in primes:
            shards = self.gearbox.encode_value(p)
            decoded = self.gearbox.decode_value(shards)
            
            if decoded != p:
                return result.failure(f"Prime {p} decoded as {decoded}")
        
        result.success(f"All {len(primes)} prime values handled correctly")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # STRESS TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_stress_large_values(self, result: TestResult):
        """Test with very large values near capacity"""
        test_values = [
            self.gearbox.max_value,
            self.gearbox.max_value - 1,
            self.gearbox.max_value - 100,
            self.gearbox.max_value // 2,
        ]
        
        for v in test_values:
            shards = self.gearbox.encode_value(v)
            decoded = self.gearbox.decode_value(shards)
            
            if decoded != v:
                return result.failure(f"Large value {v} decoded as {decoded}")
        
        result.success("Large values handled correctly")
    
    def test_stress_iterations(self, result: TestResult):
        """Stress test with many iterations"""
        iterations = 1000
        failures = 0
        
        for i in range(iterations):
            value = random.randint(0, self.gearbox.max_value)
            shards = self.gearbox.encode_value(value)
            
            # Random damage
            num_damage = random.randint(0, self.gearbox.max_failures)
            damage_indices = random.sample(range(self.gearbox.n), num_damage)
            damaged = [None if i in damage_indices else s for i, s in enumerate(shards)]
            
            try:
                decoded = self.gearbox.decode_value(damaged)
                if decoded != value:
                    failures += 1
            except:
                failures += 1
        
        if failures > 0:
            return result.failure(f"{failures}/{iterations} iterations failed")
        
        result.success(f"All {iterations} iterations passed")
    
    def test_stress_rapid_encoding(self, result: TestResult):
        """Test rapid encode/decode cycles"""
        start = time.time()
        count = 500
        
        for _ in range(count):
            value = random.randint(0, 10000)
            shards = self.gearbox.encode_value(value)
            decoded = self.gearbox.decode_value(shards)
            
            if decoded != value:
                return result.failure("Rapid encoding produced incorrect result")
        
        elapsed = time.time() - start
        rate = count / elapsed
        
        result.success(f"{rate:.0f} encode/decode cycles per second")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # MDS & INFORMATION THEORY TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_mds_property(self, result: TestResult):
        """Test Maximum Distance Separable property"""
        # MDS: Can recover from exactly n-k failures
        value = 12345
        shards = self.gearbox.encode_value(value)
        
        # n-k failures should work
        for num_failures in range(self.gearbox.max_failures + 1):
            indices = random.sample(range(self.gearbox.n), num_failures)
            damaged = [None if i in indices else s for i, s in enumerate(shards)]
            
            decoded = self.gearbox.decode_value(damaged)
            if decoded != value:
                return result.failure(f"{num_failures} failures: got {decoded}")
        
        # n-k+1 failures should fail
        indices = random.sample(range(self.gearbox.n), self.gearbox.max_failures + 1)
        damaged = [None if i in indices else s for i, s in enumerate(shards)]
        
        try:
            self.gearbox.decode_value(damaged)
            return result.failure("n-k+1 failures should have failed")
        except:
            pass
        
        result.success("MDS property verified: d = n-k+1")
    
    def test_singleton_bound(self, result: TestResult):
        """Verify Singleton bound d ≤ n-k+1 is achieved"""
        n, k = self.gearbox.n, self.gearbox.k
        d_theoretical = n - k + 1
        
        # We can tolerate d-1 erasures
        max_erasures = d_theoretical - 1
        
        if max_erasures != self.gearbox.max_failures:
            return result.failure(f"Max erasures {max_erasures} != max_failures {self.gearbox.max_failures}")
        
        result.success(f"Singleton bound achieved: d = {d_theoretical}")
    
    def test_ryu_takayanagi(self, result: TestResult):
        """Test Ryu-Takayanagi analog: S(A) = log(∏ moduli in A)"""
        # Entropy of region A should equal log of product of moduli
        for region_size in range(1, self.gearbox.n + 1):
            indices = list(range(region_size))
            moduli = [self.gearbox.primes[i] for i in indices]
            
            entropy = sum(math.log2(m) for m in moduli)
            expected = math.log2(reduce(lambda x, y: x * y, moduli))
            
            if abs(entropy - expected) > 1e-10:
                return result.failure(f"RT formula violated for size {region_size}")
        
        result.success("Ryu-Takayanagi entropy formula verified")
    
    def test_bulk_boundary(self, result: TestResult):
        """Test bulk-boundary correspondence"""
        # Bulk value uniquely determines boundary (projection)
        # k boundary pieces determine bulk (reconstruction)
        
        for _ in range(100):
            bulk = random.randint(0, self.gearbox.max_value)
            boundary = self.gearbox.crt.project(bulk)
            
            # Verify boundary determines bulk with k pieces
            reconstructed = self.gearbox.crt.reconstruct(boundary, list(range(self.gearbox.k)))
            
            if reconstructed != bulk:
                return result.failure("Bulk-boundary correspondence violated")
        
        result.success("Bulk-boundary correspondence verified")
    
    def test_entanglement_wedge(self, result: TestResult):
        """Test entanglement wedge reconstruction property"""
        value = 54321
        
        # For any k-subset, the "entanglement wedge" contains full information
        for indices in itertools.combinations(range(self.gearbox.n), self.gearbox.k):
            subset_moduli = [self.gearbox.primes[i] for i in indices]
            wedge_capacity = reduce(lambda x, y: x * y, subset_moduli)
            
            if wedge_capacity <= value:
                return result.failure(f"Wedge capacity insufficient for indices {indices}")
        
        result.success("All k-subsets have sufficient wedge capacity")
    
    def test_strong_subadditivity(self, result: TestResult):
        """Test strong subadditivity: S(ABC) + S(B) ≤ S(AB) + S(BC)"""
        # For CRT, this is an equality due to classical nature
        
        def entropy(indices):
            moduli = [self.gearbox.primes[i] for i in indices]
            return sum(math.log2(m) for m in moduli)
        
        # Test with A={0}, B={1,2}, C={3}
        A, B, C = [0], [1, 2], [3]
        AB = A + B
        BC = B + C
        ABC = A + B + C
        
        lhs = entropy(ABC) + entropy(B)
        rhs = entropy(AB) + entropy(BC)
        
        if abs(lhs - rhs) > 1e-10:
            return result.failure(f"SSA violated: {lhs} != {rhs}")
        
        result.success("Strong subadditivity holds (as equality)")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # WINDING PROPERTY TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_winding_homomorphism(self, result: TestResult):
        """Test that winding preserves ADDITIVE structure (it's linear, not multiplicative)"""
        gear = self.gearbox.gears[0]
        
        # Winding is a LINEAR map: wind(a + b) = wind(a) + wind(b) (mod m)
        # This is because wind(x) = (b * x) mod m, and multiplication distributes over addition
        for _ in range(100):
            a = random.randint(0, gear.modulus - 1)
            b = random.randint(0, gear.modulus - 1)
            
            # Test additive homomorphism: wind(a + b) = wind(a) + wind(b)
            lhs = gear.wind((a + b) % gear.modulus)
            rhs = (gear.wind(a) + gear.wind(b)) % gear.modulus
            
            if lhs != rhs:
                return result.failure(f"Additive homomorphism violated: {a} + {b}")
            
            # Test scalar multiplication: wind(c * a) = c * wind(a) for any scalar c
            c = random.randint(1, 10)
            lhs2 = gear.wind((c * a) % gear.modulus)
            rhs2 = (c * gear.wind(a)) % gear.modulus
            
            if lhs2 != rhs2:
                return result.failure(f"Scalar homomorphism violated: {c} * {a}")
        
        result.success("Winding is an additive/linear homomorphism (as expected)")
    
    def test_multi_winding(self, result: TestResult):
        """Test consistency of multi-step winding"""
        gear = self.gearbox.gears[0]
        x = 12345 % gear.modulus
        
        # Test: wind^n composed n times = wind_n_times(n)
        for n in [1, 2, 5, 10, 100]:
            # Manual composition
            current = x
            for _ in range(n):
                current = gear.wind(current)
            
            # Direct n-times
            direct = gear.wind_n_times(x, n)
            
            if current != direct:
                return result.failure(f"Multi-winding inconsistent for n={n}")
        
        result.success("Multi-step winding is consistent")


# ═══════════════════════════════════════════════════════════════════════════════
# ADDITIONAL ADVANCED TESTS
# ═══════════════════════════════════════════════════════════════════════════════

class AdvancedHolographicTests:
    """Additional advanced tests for edge cases and mathematical properties"""
    
    def __init__(self):
        self.gearbox = HolographicGearbox(n=10, k=6)
        self.results = []
    
    def run_all(self):
        print()
        print("═" * 80)
        print("    ADVANCED HOLOGRAPHIC TESTS")
        print("═" * 80)
        print()
        
        tests = [
            ("Modular Arithmetic Consistency", self.test_modular_consistency),
            ("Large Prime Handling", self.test_large_primes),
            ("Byte Encoding Roundtrip", self.test_byte_roundtrip),
            ("Multiple Chunk Encoding", self.test_multi_chunk),
            ("Shard Integrity Verification", self.test_shard_integrity),
            ("Cross-Configuration Compatibility", self.test_cross_config),
            ("Deterministic Encoding", self.test_deterministic),
            ("Inverse Operation Symmetry", self.test_inverse_symmetry),
            ("Prime Gap Robustness", self.test_prime_gaps),
            ("Coprimality Chain", self.test_coprimality_chain),
            ("Bekenstein Entropy Bound", self.test_bekenstein_bound),
            ("Planck Cell Entropy", self.test_planck_entropy),
            ("Information Paradox Resolution", self.test_info_paradox),
            ("Holographic Redundancy", self.test_holographic_redundancy),
            ("Gauge Invariance", self.test_gauge_invariance),
            ("Extreme Damage Tolerance", self.test_extreme_damage),
            ("Boundary Completeness", self.test_boundary_completeness),
            ("Wedge Nesting", self.test_wedge_nesting),
            ("Mutual Information", self.test_mutual_information),
            ("Area Law Scaling", self.test_area_law),
        ]
        
        for name, test_func in tests:
            result = TestResult(name, "Advanced")
            try:
                test_func(result)
            except Exception as e:
                result.failure(f"Exception: {e}")
            self.results.append(result)
            
            status = "✅ PASS" if result.passed else "❌ FAIL"
            print(f"  {status}: {name}")
            if result.message:
                print(f"         {result.message}")
        
        passed = sum(1 for r in self.results if r.passed)
        print()
        print(f"    Advanced Tests: {passed}/{len(self.results)} passed")
        print("═" * 80)
    
    def test_modular_consistency(self, result: TestResult):
        """Test modular arithmetic is consistent across operations"""
        m = self.gearbox.primes[0]
        
        for _ in range(100):
            a = random.randint(0, m - 1)
            b = random.randint(1, m - 1)  # Non-zero for division
            
            # Addition
            if (a + b) % m != ((a % m) + (b % m)) % m:
                return result.failure("Addition inconsistent")
            
            # Multiplication
            if (a * b) % m != ((a % m) * (b % m)) % m:
                return result.failure("Multiplication inconsistent")
        
        result.success("Modular arithmetic is consistent")
    
    def test_large_primes(self, result: TestResult):
        """Test with larger prime moduli"""
        large_gearbox = HolographicGearbox(n=10, k=6, prime_start=1000003)
        
        value = 123456789
        shards = large_gearbox.encode_value(value)
        decoded = large_gearbox.decode_value(shards)
        
        if decoded != value:
            return result.failure(f"Large prime encoding failed: {decoded}")
        
        result.success(f"Large primes starting at 1000003 work correctly")
    
    def test_byte_roundtrip(self, result: TestResult):
        """Test byte encoding roundtrip"""
        test_data = [
            b"Hello, World!",
            b"\x00\x01\x02\x03",
            b"",  # Empty
            bytes(range(256)),  # All byte values
        ]
        
        for data in test_data:
            if len(data) == 0:
                continue
            
            value = int.from_bytes(data, 'big')
            if value > self.gearbox.max_value:
                continue
            
            shards = self.gearbox.encode_value(value)
            decoded = self.gearbox.decode_value(shards)
            
            if decoded != value:
                return result.failure(f"Byte roundtrip failed for {data[:20]}...")
        
        result.success("Byte roundtrip works correctly")
    
    def test_multi_chunk(self, result: TestResult):
        """Test encoding data larger than single chunk capacity"""
        # Create data larger than max_value
        large_data = bytes(random.randint(0, 255) for _ in range(100))
        
        shards_list = self.gearbox.encode_bytes(large_data)
        
        # Verify each chunk
        for i, chunk_shards in enumerate(shards_list):
            decoded = self.gearbox.decode_value(chunk_shards)
            # Just verify it decodes without error
        
        result.success(f"Multi-chunk encoding works ({len(shards_list)} chunks)")
    
    def test_shard_integrity(self, result: TestResult):
        """Test shard integrity verification"""
        value = 42
        shards = self.gearbox.encode_value(value)
        
        for shard in shards:
            if not shard.verify_winding():
                return result.failure(f"Shard {shard.index} failed integrity check")
        
        result.success("All shards pass integrity verification")
    
    def test_cross_config(self, result: TestResult):
        """Test different n/k configurations"""
        configs = [(5, 3), (7, 4), (15, 10), (20, 12)]
        
        for n, k in configs:
            gearbox = HolographicGearbox(n=n, k=k)
            value = min(1000, gearbox.max_value)
            
            shards = gearbox.encode_value(value)
            
            # Damage max_failures shards
            indices = random.sample(range(n), n - k)
            damaged = [None if i in indices else s for i, s in enumerate(shards)]
            
            decoded = gearbox.decode_value(damaged)
            
            if decoded != value:
                return result.failure(f"Config ({n},{k}) failed")
        
        result.success(f"All {len(configs)} configurations work")
    
    def test_deterministic(self, result: TestResult):
        """Test encoding is deterministic"""
        value = 99999
        
        shards1 = self.gearbox.encode_value(value)
        shards2 = self.gearbox.encode_value(value)
        
        for s1, s2 in zip(shards1, shards2):
            if s1.wound_residue != s2.wound_residue:
                return result.failure("Encoding is not deterministic")
        
        result.success("Encoding is deterministic")
    
    def test_inverse_symmetry(self, result: TestResult):
        """Test wind/unwind symmetry"""
        for gear in self.gearbox.gears:
            for _ in range(50):
                x = random.randint(0, gear.modulus - 1)
                
                # wind then unwind
                if gear.unwind(gear.wind(x)) != x:
                    return result.failure("wind->unwind asymmetric")
                
                # unwind then wind
                if gear.wind(gear.unwind(x)) != x:
                    return result.failure("unwind->wind asymmetric")
        
        result.success("Wind/unwind operations are symmetric")
    
    def test_prime_gaps(self, result: TestResult):
        """Test robustness to prime gaps"""
        # Use primes with intentionally larger gaps
        primes = generate_primes(1000000, 10)
        
        gearbox = HolographicGearbox(n=10, k=6, prime_start=1000000)
        
        value = 12345
        shards = gearbox.encode_value(value)
        decoded = gearbox.decode_value(shards)
        
        if decoded != value:
            return result.failure("Prime gap test failed")
        
        result.success("Robust to various prime gaps")
    
    def test_coprimality_chain(self, result: TestResult):
        """Verify coprimality is maintained throughout the chain"""
        primes = self.gearbox.primes
        
        # All pairs should be coprime
        for i in range(len(primes)):
            for j in range(i + 1, len(primes)):
                if not is_coprime(primes[i], primes[j]):
                    return result.failure(f"Primes {primes[i]} and {primes[j]} not coprime")
        
        # All bases should be coprime to their moduli
        for gear in self.gearbox.gears:
            if not is_coprime(gear.base, gear.modulus):
                return result.failure(f"Base {gear.base} not coprime to modulus {gear.modulus}")
        
        result.success("Complete coprimality chain verified")

    # ═══════════════════════════════════════════════════════════════════════════
    # QUANTUM ANALOG TESTS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def test_bekenstein_bound(self, result: TestResult):
        """Test Bekenstein entropy bound analog: S ≤ log₂(M)"""
        # The bulk capacity M sets the maximum entropy
        M = self.gearbox.crt.M
        max_entropy = math.log2(M)
        
        # The k-threshold capacity sets the usable entropy
        M_k = self.gearbox.crt.bulk_capacity(self.gearbox.k)
        usable_entropy = math.log2(M_k)
        
        # Bekenstein analog: usable entropy is bounded by boundary entropy
        if usable_entropy > max_entropy:
            return result.failure("Bekenstein bound violated")
        
        result.success(f"Bekenstein bound satisfied: {usable_entropy:.1f} ≤ {max_entropy:.1f} bits")
    
    def test_planck_entropy(self, result: TestResult):
        """Test that each prime contributes log₂(p) bits (Planck cell analog)"""
        primes = self.gearbox.primes
        
        # Total entropy from sum of individual primes
        sum_entropy = sum(math.log2(p) for p in primes)
        
        # Total entropy from product
        product_entropy = math.log2(reduce(lambda x, y: x * y, primes))
        
        # Should be equal: log(∏p) = Σlog(p)
        if abs(sum_entropy - product_entropy) > 1e-10:
            return result.failure("Planck cell entropy mismatch")
        
        result.success(f"Planck cell entropy verified: {sum_entropy:.2f} bits from {len(primes)} cells")
    
    def test_info_paradox(self, result: TestResult):
        """Test information paradox resolution: information is never lost"""
        value = 42424
        shards = self.gearbox.encode_value(value)
        
        # Simulate "Hawking radiation" - shards becoming available one by one
        available = []
        reconstructable = False
        
        for shard in shards:
            available.append(shard)
            if len(available) >= self.gearbox.k:
                # Try reconstruction
                padded = available + [None] * (self.gearbox.n - len(available))
                try:
                    decoded = self.gearbox.decode_value(padded)
                    if decoded == value:
                        reconstructable = True
                        break
                except:
                    pass
        
        if not reconstructable:
            return result.failure("Information paradox: data not recoverable")
        
        result.success(f"Information recovered after {len(available)} shards (paradox resolved)")
    
    def test_holographic_redundancy(self, result: TestResult):
        """Test holographic redundancy: same info encoded multiple ways"""
        value = 31415
        shards = self.gearbox.encode_value(value)
        
        # Count distinct recovery paths
        recovery_paths = 0
        for indices in itertools.combinations(range(self.gearbox.n), self.gearbox.k):
            subset = [shards[i] if i in indices else None for i in range(self.gearbox.n)]
            try:
                decoded = self.gearbox.decode_value(subset)
                if decoded == value:
                    recovery_paths += 1
            except:
                pass
        
        expected_paths = math.comb(self.gearbox.n, self.gearbox.k)
        
        if recovery_paths != expected_paths:
            return result.failure(f"Only {recovery_paths}/{expected_paths} recovery paths work")
        
        result.success(f"Holographic redundancy: {recovery_paths} equivalent recovery paths")
    
    def test_gauge_invariance(self, result: TestResult):
        """Test gauge invariance: physics (information) is preserved under winding"""
        value = 27182
        shards = self.gearbox.encode_value(value)
        
        # The raw residues (before winding) should be gauge-invariant
        for shard in shards:
            gear = SafeGear(shard.modulus, shard.base)
            
            # Multiple windings should all unwind to same raw residue
            wound = shard.wound_residue
            for _ in range(10):
                wound = gear.wind(wound)
            
            # Unwind all the way back
            unwound = wound
            for _ in range(11):  # 10 extra winds + 1 original
                unwound = gear.unwind(unwound)
            
            if unwound != shard.raw_residue:
                return result.failure("Gauge invariance violated")
        
        result.success("Gauge invariance verified under multiple windings")
    
    def test_extreme_damage(self, result: TestResult):
        """Test extreme damage tolerance configurations"""
        extreme_configs = [
            (10, 2),   # 80% damage tolerance
            (20, 4),   # 80% damage tolerance
            (100, 10), # 90% damage tolerance
        ]
        
        for n, k in extreme_configs:
            gearbox = HolographicGearbox(n=n, k=k)
            value = min(1000, gearbox.max_value)
            
            shards = gearbox.encode_value(value)
            
            # Damage to maximum tolerance
            damage_count = n - k
            damage_indices = random.sample(range(n), damage_count)
            damaged = [None if i in damage_indices else s for i, s in enumerate(shards)]
            
            try:
                decoded = gearbox.decode_value(damaged)
                if decoded != value:
                    return result.failure(f"Config ({n},{k}) with {damage_count} damage failed")
            except:
                return result.failure(f"Config ({n},{k}) raised exception")
        
        result.success(f"Extreme damage tolerance verified up to 90%")
    
    def test_boundary_completeness(self, result: TestResult):
        """Test that boundary (shards) completely encodes bulk (data)"""
        # Every valid bulk value should have a unique boundary representation
        test_values = random.sample(range(min(10000, self.gearbox.max_value)), 100)
        
        boundaries = {}
        for v in test_values:
            shards = self.gearbox.encode_value(v)
            boundary = tuple((s.wound_residue, s.modulus) for s in shards)
            
            if boundary in boundaries:
                return result.failure(f"Boundary collision: {v} and {boundaries[boundary]}")
            boundaries[boundary] = v
        
        result.success("Boundary-bulk encoding is injective (no collisions)")
    
    def test_wedge_nesting(self, result: TestResult):
        """Test entanglement wedge nesting: larger regions contain more info"""
        # For regions A ⊂ B, wedge(A) ⊂ wedge(B)
        # In CRT terms: product of subset moduli divides product of superset
        
        for size1 in range(1, self.gearbox.n):
            for size2 in range(size1 + 1, self.gearbox.n + 1):
                indices1 = list(range(size1))
                indices2 = list(range(size2))
                
                moduli1 = [self.gearbox.primes[i] for i in indices1]
                moduli2 = [self.gearbox.primes[i] for i in indices2]
                
                product1 = reduce(lambda x, y: x * y, moduli1)
                product2 = reduce(lambda x, y: x * y, moduli2)
                
                if product2 % product1 != 0:
                    return result.failure(f"Wedge nesting violated: {size1} vs {size2}")
        
        result.success("Entanglement wedge nesting verified")
    
    def test_mutual_information(self, result: TestResult):
        """Test mutual information between shard pairs"""
        # For independent moduli, mutual info should be zero
        # I(A;B) = H(A) + H(B) - H(A,B)
        
        for i in range(len(self.gearbox.primes)):
            for j in range(i + 1, len(self.gearbox.primes)):
                p_i = self.gearbox.primes[i]
                p_j = self.gearbox.primes[j]
                
                H_A = math.log2(p_i)
                H_B = math.log2(p_j)
                H_AB = math.log2(p_i * p_j)  # Joint entropy
                
                mutual_info = H_A + H_B - H_AB
                
                # Should be zero for independent (coprime) moduli
                if abs(mutual_info) > 1e-10:
                    return result.failure(f"Non-zero mutual info between shards {i} and {j}")
        
        result.success("Shards have zero pairwise mutual information (independence)")
    
    def test_area_law(self, result: TestResult):
        """Test area law: entropy scales linearly with region size"""
        entropies = []
        sizes = list(range(1, self.gearbox.n + 1))
        
        for size in sizes:
            indices = list(range(size))
            moduli = [self.gearbox.primes[i] for i in indices]
            entropy = sum(math.log2(m) for m in moduli)
            entropies.append(entropy)
        
        # Check linearity: entropy should be proportional to size
        # Fit: S = a * size + b, check R² ≈ 1
        n = len(sizes)
        mean_x = sum(sizes) / n
        mean_y = sum(entropies) / n
        
        ss_xy = sum((sizes[i] - mean_x) * (entropies[i] - mean_y) for i in range(n))
        ss_xx = sum((sizes[i] - mean_x) ** 2 for i in range(n))
        ss_yy = sum((entropies[i] - mean_y) ** 2 for i in range(n))
        
        r_squared = (ss_xy ** 2) / (ss_xx * ss_yy) if ss_xx * ss_yy > 0 else 0
        
        if r_squared < 0.999:  # Very linear for prime moduli
            return result.failure(f"Area law violated: R² = {r_squared:.4f}")
        
        result.success(f"Area law verified: entropy ∝ size (R² = {r_squared:.6f})")


# ═══════════════════════════════════════════════════════════════════════════════
# PERFORMANCE BENCHMARKS
# ═══════════════════════════════════════════════════════════════════════════════

class PerformanceBenchmarks:
    """Performance benchmarks for the Holographic Gearbox"""
    
    def __init__(self):
        self.results = {}
    
    def run_all(self):
        print()
        print("═" * 80)
        print("    PERFORMANCE BENCHMARKS")
        print("═" * 80)
        print()
        
        benchmarks = [
            ("SafeGear Winding", self.bench_winding),
            ("CRT Projection", self.bench_projection),
            ("CRT Reconstruction", self.bench_reconstruction),
            ("Full Encode/Decode", self.bench_full_cycle),
            ("Damaged Decode", self.bench_damaged_decode),
            ("Large Value Encoding", self.bench_large_values),
        ]
        
        for name, bench_func in benchmarks:
            result = bench_func()
            self.results[name] = result
            print(f"  {name}: {result['ops_per_sec']:.0f} ops/sec ({result['avg_ms']:.3f} ms/op)")
        
        print()
        print("═" * 80)
    
    def _time_operation(self, func, iterations=1000):
        """Time an operation over many iterations"""
        start = time.time()
        for _ in range(iterations):
            func()
        elapsed = time.time() - start
        
        return {
            'total_time': elapsed,
            'iterations': iterations,
            'avg_ms': (elapsed / iterations) * 1000,
            'ops_per_sec': iterations / elapsed
        }
    
    def bench_winding(self):
        gearbox = HolographicGearbox()
        gear = gearbox.gears[0]
        
        def op():
            x = random.randint(0, gear.modulus - 1)
            gear.wind(x)
            gear.unwind(x)
        
        return self._time_operation(op, 10000)
    
    def bench_projection(self):
        gearbox = HolographicGearbox()
        
        def op():
            value = random.randint(0, gearbox.max_value)
            gearbox.crt.project(value)
        
        return self._time_operation(op, 5000)
    
    def bench_reconstruction(self):
        gearbox = HolographicGearbox()
        value = 12345
        residues = gearbox.crt.project(value)
        
        def op():
            gearbox.crt.reconstruct(residues)
        
        return self._time_operation(op, 5000)
    
    def bench_full_cycle(self):
        gearbox = HolographicGearbox()
        
        def op():
            value = random.randint(0, 10000)
            shards = gearbox.encode_value(value)
            gearbox.decode_value(shards)
        
        return self._time_operation(op, 1000)
    
    def bench_damaged_decode(self):
        gearbox = HolographicGearbox()
        
        def op():
            value = random.randint(0, 10000)
            shards = gearbox.encode_value(value)
            # Damage some shards
            indices = random.sample(range(gearbox.n), gearbox.max_failures)
            damaged = [None if i in indices else s for i, s in enumerate(shards)]
            gearbox.decode_value(damaged)
        
        return self._time_operation(op, 500)
    
    def bench_large_values(self):
        gearbox = HolographicGearbox()
        
        def op():
            value = gearbox.max_value - random.randint(0, 1000)
            shards = gearbox.encode_value(value)
            gearbox.decode_value(shards)
        
        return self._time_operation(op, 500)


# ═══════════════════════════════════════════════════════════════════════════════
# MAIN EXECUTION
# ═══════════════════════════════════════════════════════════════════════════════

def main():
    """Run all test suites"""
    print()
    print("🌪️💜 HYPERMORPHIC HOLOGRAPHIC GEARBOX TEST SUITE 💜🌪️")
    print()
    
    # Core tests
    core_suite = HolographicGearboxTestSuite()
    core_results = core_suite.run_all()
    
    # Advanced tests
    advanced_suite = AdvancedHolographicTests()
    advanced_suite.run_all()
    
    # Performance benchmarks
    benchmarks = PerformanceBenchmarks()
    benchmarks.run_all()
    
    # Final summary
    total_passed = core_results['passed'] + sum(1 for r in advanced_suite.results if r.passed)
    total_tests = core_results['total'] + len(advanced_suite.results)
    
    print()
    print("═" * 80)
    print(f"    FINAL SUMMARY: {total_passed}/{total_tests} tests passed ({100*total_passed/total_tests:.1f}%)")
    print("═" * 80)
    print()
    print("    🌪️💜 THE UNIVERSE FLOWS THROUGH COPRIME GEARS 💜🌪️")
    print()
    
    return total_passed == total_tests


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)



